import pytest
import sympy
import time
import sys
import os

# Add project root to Python path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from transformer.generator import (
    generate_random_circuit,
    generate_random_polynomials,
    get_symbols,
    _canonical_key,
)

# --- Test Fixtures ---

@pytest.fixture(scope="module")
def config():
    """Provides a standard configuration for tests."""
    return {
        "n": 3,
        "C": 5,
        "mod": 7,
        "num_polynomials": 100,
    }

@pytest.fixture(scope="module")
def symbols(config):
    """Provides SymPy symbols for tests."""
    return get_symbols(config["n"])

# --- Test Cases ---

def test_generate_random_circuit_output_types(config):
    """
    Test that `generate_random_circuit` returns data in the expected SymPy-based format.
    """
    n, C, mod = config["n"], config["C"], config["mod"]
    
    actions, polynomials = generate_random_circuit(n, C, mod)

    assert isinstance(actions, list)
    assert isinstance(polynomials, list)
    
    if actions:
        # Base actions are ('input', var_idx, -1) or ('constant', -1, -1)
        # Operation actions are ('add'/'multiply', node1, node2)
        assert isinstance(actions[0], tuple)
        assert len(actions[0]) == 3
    
    if polynomials:
        # Polynomials should now be SymPy expressions
        assert isinstance(polynomials[0], sympy.Expr)

def test_generate_random_polynomials_output_types(config):
    """
    Test that `generate_random_polynomials` returns SymPy expressions.
    """
    n, C, mod, num_p = config.values()

    all_polynomials, all_circuits = generate_random_polynomials(
        n, C, num_polynomials=num_p, mod=mod
    )

    assert isinstance(all_polynomials, list)
    assert isinstance(all_circuits, list)
    
    if num_p > 0:
        assert len(all_polynomials) > 0, "Should generate at least one polynomial"
        assert len(all_circuits) > 0, "Should generate at least one circuit"
        # Check that the outputs are of the correct type
        assert isinstance(all_polynomials[0], sympy.Expr)
        assert isinstance(all_circuits[0], list)

def test_deduplication_in_generate_random_circuit(config):
    """
    Verify that `generate_random_circuit` does not produce duplicate polynomials
    within its own execution, thanks to internal SymPy-based deduplication.
    """
    n, C, mod = 2, 15, 5
    
    _, polynomials = generate_random_circuit(n, C, mod)
    
    symbols = get_symbols(n)
    seen_keys = set()
    for expr in polynomials:
        key = _canonical_key(expr, symbols)
        assert key not in seen_keys, f"Duplicate polynomial found in circuit: {expr}"
        seen_keys.add(key)

def test_deduplication_in_generate_random_polynomials(config):
    """
    Checks that the final list of polynomials from `generate_random_polynomials`
    contains no duplicates.
    """
    n, C, mod = 2, 8, 5
    num_p = 200
    
    all_polynomials, _ = generate_random_polynomials(
        n, C, num_polynomials=num_p, mod=mod
    )
    
    # The generator might not always be able to produce the exact number requested
    # if it runs out of unique options. This is acceptable.
    print(f"Requested {num_p} polynomials, got {len(all_polynomials)} unique ones.")
    
    symbols = get_symbols(n)
    final_poly_keys = set()
    for expr in all_polynomials:
        key = _canonical_key(expr, symbols)
        assert key not in final_poly_keys, f"Duplicate polynomial found in dataset: {expr}"
        final_poly_keys.add(key)
    
    assert len(all_polynomials) == len(final_poly_keys)

def test_canonical_key_commutativity(symbols):
    """
    Test that the canonical key is the same for commutative expressions like x*y and y*x.
    """
    x, y, z = symbols[0], symbols[1], symbols[2]
    
    expr1 = x * y + z
    expr2 = y * x + z
    
    key1 = _canonical_key(expr1, symbols)
    key2 = _canonical_key(expr2, symbols)
    
    assert key1 == key2, "Canonical key should be identical for commutative expressions."

def test_canonical_key_factored_vs_expanded(symbols):
    """
    Test that factored and expanded forms of the same polynomial have the same key.
    """
    x, y = symbols[0], symbols[1]
    
    expr_factored = (x + y) ** 2
    expr_expanded = x**2 + 2*x*y + y**2
    
    key1 = _canonical_key(expr_factored, symbols)
    key2 = _canonical_key(expr_expanded, symbols)
    
    assert key1 == key2, "Canonical key should be identical for factored and expanded forms."

def test_algebraic_correctness_of_circuit(config):
    """
    Verifies that the polynomials generated by a circuit correctly correspond to the actions.
    """
    n, C, mod = config["n"], config["C"], config["mod"]
    symbols = get_symbols(n)
    
    actions, polynomials = generate_random_circuit(n, C, mod)
    
    # Reconstruct polynomials from actions and check against the generated ones
    reconstructed_polys = []
    for i, (op, p1_idx, p2_idx) in enumerate(actions):
        if op == 'input':
            # This assumes the initial symbols are set up in the same order as the generator
            reconstructed_polys.append(get_symbols(n)[p1_idx])
        elif op == 'constant':
            reconstructed_polys.append(sympy.Integer(1))
        elif op == 'add':
            poly = reconstructed_polys[p1_idx] + reconstructed_polys[p2_idx]
            poly = sympy.Poly(poly, symbols).map_coeffs(lambda c: c % mod).as_expr()
            reconstructed_polys.append(poly)
        elif op == 'multiply':
            poly = reconstructed_polys[p1_idx] * reconstructed_polys[p2_idx]
            poly = sympy.Poly(poly, symbols).map_coeffs(lambda c: c % mod).as_expr()
            reconstructed_polys.append(poly)
            
        # Compare the reconstructed poly with the one from the generator
        # The generator already produces canonical (expanded, modulo) polynomials
        gen_poly = polynomials[i]
        rec_poly = reconstructed_polys[-1]
        
        assert sympy.expand(gen_poly - rec_poly) == 0, \
            f"Mismatch at step {i}: Gen: {gen_poly}, Rec: {rec_poly}"

def test_performance_generation(config):
    """
    Basic performance check to ensure generation time is within a reasonable limit.
    """
    n, C, mod = 3, 10, 11
    num_p = 500

    # A rough baseline. The SymPy version might be slightly slower, which is acceptable.
    baseline_time = 10.0 
    
    start_time = time.time()
    generate_random_polynomials(n, C, num_polynomials=num_p, mod=mod)
    end_time = time.time()
    
    duration = end_time - start_time
    print(f"Generation of {num_p} polynomials took {duration:.2f} seconds.")
    
    assert duration <= baseline_time * 1.5, f"Performance regression detected: took {duration:.2f}s, baseline is {baseline_time:.2f}s."
